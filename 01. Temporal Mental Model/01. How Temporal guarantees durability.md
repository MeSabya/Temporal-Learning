## Why replay is necessary and how Temporal guarantees durability. ..explain with an example ...

### Why Replay Is Necessary Because:

- Workers crash
- Pods restart
- Deployments happen
- Machines die
- Memory is not durable

### Durability 

Temporal durability comes from 3 guarantees

#### Guarantee 1: History is immutable and durable

- Stored in DB
- Append-only
- Survives crashes

#### Guarantee 2: Workflow code is deterministic

- Same history → same execution
- Replay produces identical decisions
- If not → Temporal fails fast

#### Guarantee 3: Activities are side-effect boundaries

- Activities do real-world work
- Results are recorded
- Never re-executed unless retrying
- Concrete Example (Step by Step)
- Business Workflow

### Example
“Place order → charge payment → send confirmation”

```golang
func ChargeCustomer(ctx context.Context, orderID string) error {
	fmt.Println("Charging customer for order:", orderID)
	time.Sleep(2 * time.Second)
	return nil
}

/*func SendConfirmation(ctx context.Context, orderID string) error {
   exit(1)
}
```

#### What Temporal stores (History)

Temporal does NOT store variables.
It stores events:

- WorkflowStarted
- ActivityScheduled(ChargePayment)
- ActivityCompleted(ChargePayment)
- ActivityScheduled(SendConfirmation)
- This history is stored durably in Temporal DB.

#### Worker crashes

- Workflow was waiting for SendConfirmation
- Worker pod is gone
- Memory = lost

#### New worker picks it up (Replay)

- Temporal gives the entire history to the new worker.
Worker:
  - Starts executing workflow from line 1

But now…

#### Replay behavior (This is the magic)

- workflow.ExecuteActivity(ChargePayment)
- Temporal sees in history:
- ActivityCompleted(ChargePayment)
- So it does not schedule it again.
Instead:

- Returns cached result
- Continues execution
- Same for every step.

#### Workflow continues safely

- workflow.ExecuteActivity(SendConfirmation)
- This one was not completed yet → scheduled again.

- Payment not double-charged
- Workflow resumes correctly
- No state lost


### Temporal Replay & Durability — Summary

#### Temporal never trusts worker memory
Workers can crash, restart, or be redeployed at any time.

#### Durability comes from event history

Temporal persistently stores what happened (events), not variables or in-memory state.

#### Workflow code is replayed to rebuild state

On restart, Temporal re-executes the workflow code from the beginning using the stored history.

Completed steps are not re-executed; results are replayed from history.

#### Replay requires determinism

Given the same history, workflow code must make the same decisions.

Non-deterministic logic (rand, time.Now, goroutines, etc.) causes workflow failure.

Activities are side-effect boundaries

Real-world work happens in activities.

Activity results are recorded once and reused during replay.

#### This is how Temporal guarantees durability

Crashes do not lose progress.

Long-running workflows can safely resume after minutes, days, or months.
